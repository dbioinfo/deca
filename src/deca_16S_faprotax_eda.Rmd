---
title: "deca_16S_faprotax_eda"
author: "Dylan Barth"
date: "2026-01-13"
output: html_document
---


```{r setup, include=F}
library(tidyverse)
library(dada2)
library(phyloseq)
library(ComplexHeatmap)
library(circlize)
library(scales)  
library(shiny)
library(ggalluvial)
library(rlang)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '~/WorkForaging/Academia/Nicole/deca/')
```


## Import Data

Here we import a preprocessed functional annotation to reduce memory usage. See `src/deca_EDA.R` for details. We read in the data from the phyloseq object in order to demonstrate a standardized flow, but this takes a few seconds longer to run than just reading in the tables themselves. 


```{r import, include=F}
#data
ps <- readRDS('data/16Sdada2/phyloseq.filtered.rds')
otu <- data.frame(otu_table(ps))
meta <- data.frame(sample_data(ps))
tf <- readRDS('data/16Sfaprotax/faprotax_abund.rds')

#global vars
timelevs <- c("Jul_2022","Nov_2022","Feb_2023", "Aug_2023","Nov_2023", "Feb_2024","Aug_2024")
timecols <- c("#D1895C","#DDBF88","#88A6DD","#8CDE93","#D2AA60","#6088D2","#47B851")
treatlevs <- c("Baseline","Control","Water","N", "N+P","N+Water","P","P+Water","N+P+Water")
treatcols <- c("#E3E571","#E5AE71","#71C4E5","#53DF7B","#C0E5A4","#BCE7D6","#DF53B7","#E7BCCC","#804DEF")
mhablevs <- c("SI","SG","SSI","SSG")
mcols <- c("#B897DD","#BCDD97","#B43FEE","#78EE3F")
sscols <- c("#B897DD", "#B43FEE")
gicols <- c("#BCDD97", "#B897DD")
mshapes <- c(25,10,17,16)

#order the data
meta <- meta %>% 
  mutate(Treatment = factor(Treatment, levels=treatlevs),
         Microhabitat = factor(Microhabitat, levels=mhablevs),
         Surface_Subsurface = factor(Surface_Subsurface, levels=c('S','SS')),
         Grass_Interspace = factor(Grass_Interspace, levels=c("G","I")),
         SampleDate = factor(SampleDate, levels=timelevs))

```


## Prepare graph data

Alluvial plots require data in a very specific format, here we prepare the data to be used in the interactive visualization. First the data is subset to include only ASVs found in the annotation. Next a map between ASVs and functions is generated. Then the otu table is subset and converted to relative abundance. Finally annotations from metadata and taxonomic ranks are joined in. 

```{r prepare-data}
#process data for alluvial plots
vbles <- unique(tf$res_spe_func_perc_trans$variable)
asv_idx <- which(rowSums(tf$res_spe_func[,vbles])>0)
asv_2_cat <- tf$res_spe_func[,vbles] %>% rownames_to_column("ASV") %>% 
  pivot_longer(!ASV, names_to = 'variable', values_to = 'present') %>% 
  filter(present>0) %>% select(!present)
funcdat <- tf$res_spe_func_perc_trans %>% rename(SampleID=sampname) %>% 
  merge(., asv_2_cat, by='variable')
tax <- tf$tax_table[asv_idx,] %>% rownames_to_column("ASV")
gdat <- otu[,asv_idx] %>% rownames_to_column("SampleID") %>% 
  pivot_longer(!SampleID, names_to = 'ASV', values_to = 'Abundance') %>% 
  group_by(SampleID) %>% mutate(Abundance=Abundance/sum(Abundance)) %>% 
  left_join(., meta, by='SampleID') %>% 
  left_join(., tax, by='ASV') 

```


## Shiny Alluvial Plot

Here we generate a shiny applet that takes several user inputs from the sidebar and creates custom alluvial plots in the main panel. 

Included in the customization options on the sidebar: 
  - Functional Group: One or many of the following `C-cycle` `N-cycle` `S-cycle` `Energy source` `Other`
  - Taxonomic Scope: Taxonomic grouping to be used, one or many of the following `Kingdom` `Phylum`  `Class`   `Order`   `Family`  `Genus`   `Species`
  - Functional Inclusion: Which variables are to be included within the functional group 
  - Metadata Axis: Which of the metadata variables to include, one or many of `SampleDate` `Microhabitat` `Treatment` `Surface_Subsurface` `Grass_Interspace`
  - Metadata Filter: Which values of metadata variables to include. For each metadata variable above, choose which unique values to include, default 'all' 
  - Weight Cutoff: There are many low-abundance taxa that crowd the graph, this filter cleans up the rare taxa. Range 0 - 10 (log10 scale).
  - Weight by FAPROTAX enrichment: The thickness on the alluvial plot can reflect relative abundance scaled by functional enrichment (checked) or just relative abundance (unchecked)


```{r shiny-alluvial, echo=FALSE, message=FALSE, warning=FALSE}

# ---- UI ----
all_groups <- sort(unique(funcdat$group))
all_tax_ranks <- c("Kingdom","Phylum","Class","Order","Family","Genus","Species")
all_meta_axes <- c("Microhabitat","Treatment","Surface_Subsurface","Grass_Interspace","SampleDate")

ui <- fluidPage(
  titlePanel("Functional Alluvial Plots"),
  sidebarLayout(
    sidebarPanel(
      selectizeInput(
        "f_groups", "Functional Group(s)",
        choices = all_groups, selected = "C-cycle",
        multiple = TRUE, options = list(plugins = list("remove_button"))
      ),

      selectizeInput(
        "tax_ranks", "Taxonomic Scope (one or many ranks)",
        choices = all_tax_ranks, selected = "Genus",
        multiple = TRUE, options = list(plugins = list("remove_button"))
      ),

      uiOutput("func_inclusion_ui"),

      checkboxGroupInput(
        "meta_axes", "Metadata Axis",
        choices = all_meta_axes, selected = "Microhabitat"
      ),
      uiOutput("meta_filter_ui"),

      sliderInput(
        "weight_cutoff_log10", "Weight Cutoff (log10 scale)",
        min = -3, max = 1, value = -1, step = 0.05
    ),
      checkboxInput(
        "use_enrichment", "Weight by FAPROTAX enrichment score", value = TRUE
    ),
      actionButton("refresh", "Refresh", class = "btn-primary")
    ),
    
    mainPanel(
      plotOutput("alluvial_plot", width="1250px", height = "750px")
    )
  )
)

#--- SERVER ---
server <- function(input, output, session) {

  ###Generate the UI on the backend
  #Functional variables available under selected groups
  output$func_inclusion_ui <- renderUI({
    req(input$f_groups)
    vars <- funcdat %>% 
      dplyr::filter(group %in% input$f_groups) %>% 
      dplyr::pull(variable) %>% 
      unique() %>% 
      sort()

    selectizeInput(
      "func_vars", "Functional Inclusion (variables within selected groups)",
      choices = vars,
      selected = vars,  
      multiple = TRUE,
      options = list(plugins = list("remove_button"))
    )
  })

  #One filter per selected metadata axis
  output$meta_filter_ui <- renderUI({
    axes <- input$meta_axes
    if (is.null(axes) || length(axes) == 0) return(NULL)

    tagList(lapply(axes, function(ax) {
      vals <- gdat %>% 
        dplyr::pull(!!sym(ax)) %>% 
        unique() %>% 
        sort()

      selectizeInput(
        paste0("meta_", ax),
        label = paste0("Filter: ", ax),
        choices = vals,
        selected = vals,  # default: all
        multiple = TRUE,
        options = list(plugins = list("remove_button"))
      )
    }))
  })

  ###Build plot on Refresh
  plot_dat <- eventReactive(input$refresh, {
  req(input$f_groups, input$tax_ranks, input$func_vars)

  funcdat_sub <- funcdat %>%
    dplyr::filter(group %in% input$f_groups, variable %in% input$func_vars) 

  dat <- gdat %>%
    dplyr::filter(ASV %in% unique(funcdat_sub$ASV) ) %>%
    dplyr::left_join(funcdat_sub, by = c("ASV", "SampleID"))
    #Apply metadata filters 
    axes <- input$meta_axes %||% character(0)
    fill_var <- if (length(axes) > 0) axes[[1]] else "variable"
    
    if (!is.null(axes) && length(axes) > 0) {
      for (ax in axes) {
        sel <- input[[paste0("meta_", ax)]]
        if (!is.null(sel) && length(sel) > 0) {
          dat <- dat %>%  dplyr::filter(.data[[ax]] %in% sel)
        }
      }
    }

    #Build a single tax label from selected ranks (order matters here)
    ranks <- intersect(input$tax_ranks, colnames(dat))
    req(length(ranks) > 0)

    dat <- dat %>% 
      tidyr::unite("tax", dplyr::all_of(ranks), sep = "; ", remove = FALSE, na.rm = TRUE)

    #X axis
    axis_cols <- c(axes, "group", "variable", "tax")

    #calculate final data
    #weight by enrich score? 
    if (input$use_enrichment){ #(sum of rel abund) x enrichment score from faprotax
      dat <- dat %>% 
        dplyr::group_by(dplyr::across(dplyr::all_of(axis_cols))) %>% 
        dplyr::summarize(weight = sum(Abundance*value, na.rm = TRUE), .groups = "drop") %>% 
        dplyr::filter(weight >= 10^input$weight_cutoff_log10)
    } else { #just relative abundance
      dat <- dat %>% 
        dplyr::group_by(dplyr::across(dplyr::all_of(axis_cols))) %>% 
        dplyr::summarize(weight = sum(Abundance, na.rm = TRUE), .groups = "drop") %>% 
        dplyr::filter(weight >= 10^input$weight_cutoff_log10)
    }
    
    list(dat = dat, axis_cols = axis_cols, fill_var = fill_var)
    
  }, ignoreNULL = FALSE)

  output$alluvial_plot <- renderPlot({
    obj <- plot_dat()
    dat <- obj$dat
    validate(shiny::need(nrow(dat) > 0, "No data after filters."))

    #X axis
    axis_cols <- obj$axis_cols

    fill_var <- if (!is.null(obj$fill_var)) obj$fill_var else "variable"

    #Build aes 
    axis_aes <- setNames(
      lapply(axis_cols, rlang::sym),
      paste0("axis", seq_along(axis_cols))
    )

    #Plot
    p <- ggplot(dat, aes(!!!axis_aes, y = weight)) +
      geom_alluvium(aes(fill = .data[[fill_var]]), alpha = 0.8) +
      geom_stratum(fill = "grey90", color = "grey40") +
      geom_text(
        stat = "stratum",
        aes(label = after_stat(stratum)),
        size = 5
      ) +
      scale_x_discrete(limits = axis_cols) +
      theme_bw() +
      theme(axis.text = element_text(size=15))+
      ggtitle(paste("Alluvial:", paste(input$f_groups, collapse = ", ")))

    # Manual fill scales based on chosen fill variable
    if (fill_var == "Treatment") {
      p <- p + scale_fill_manual(values = treatcols)
    } else if (fill_var == "Microhabitat") {
      p <- p + scale_fill_manual(values = mcols)
    } else if (fill_var == "Surface_Subsurface") {
      p <- p + scale_fill_manual(values = sscols)
    } else if (fill_var == "Grass_Interspace") {
      p <- p + scale_fill_manual(values = gicols)
    } else if (fill_var == "SampleDate") {
      p <- p + scale_fill_manual(values = timecols)
    }

    p
  })
}

shinyApp(ui, server)
```


